
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin
import socket

def scan_xss(url):
    print(f"Scanning for XSS vulnerabilities on: {url}")
    forms = get_all_forms(url)
    print(f"Found {len(forms)} forms on {url}")

    for form in forms:
        """Simulate XSS attack"""
        details = form_details(form)
        action_url = urljoin(url, details["action"])
        method = details["method"]

        # Test all input fields
        data = {}
        for input_tag in details["inputs"]:
            if input_tag["type"] == "text" or input_tag["type"] == "search":
                data[input_tag["name"]] = "<script>alert(\'XSS\')</script>"
            else:
                data[input_tag["name"]] = input_tag["value"]

        try:
            if method == "post":
                res = requests.post(action_url, data=data, timeout=5)
            elif method == "get":
                res = requests.get(action_url, params=data, timeout=5)

            if "<script>alert(\'XSS\')</script>" in res.text:
                print(f"[+] XSS Detected on {action_url}")
                print(f"Form details:")
                print(details)
        except requests.exceptions.RequestException as e:
            print(f"[ ] Could not reach {action_url}: {e}")

def get_all_forms(url):
    """Returns all form tags found on a web page's url"""
    try:
        soup = BeautifulSoup(requests.get(url, timeout=5).content, "html.parser")
        return soup.find_all("form")
    except requests.exceptions.RequestException as e:
        print(f"[ ] Error fetching forms from {url}: {e}")
        return []

def form_details(form):
    """Extracts form details"""
    details = {}
    action = form.attrs.get("action", "").lower()
    method = form.attrs.get("method", "get").lower()
    inputs = []

    for input_tag in form.find_all("input"):
        input_type = input_tag.attrs.get("type", "text")
        input_name = input_tag.attrs.get("name")
        input_value = input_tag.attrs.get("value", "")
        inputs.append({"type": input_type, "name": input_name, "value": input_value})

    details["action"] = action
    details["method"] = method
    details["inputs"] = inputs
    return details

def scan_sql_injection(url, payload="\' OR \'1\'=\'1"): # Basic SQL Injection payload
    print(f"Scanning for SQL Injection vulnerabilities on: {url}")
    forms = get_all_forms(url)

    for form in forms:
        details = form_details(form)
        action_url = urljoin(url, details["action"])
        method = details["method"]

        for input_tag in details["inputs"]:
            if input_tag["type"] == "text" or input_tag["type"] == "search":
                data = {input_tag["name"]: payload}
                try:
                    if method == "post":
                        res = requests.post(action_url, data=data, timeout=5)
                    elif method == "get":
                        res = requests.get(action_url, params=data, timeout=5)

                    if "You have an error in your SQL syntax" in res.text or \
                       "Warning: mysql_fetch_array()" in res.text or \
                       "SQLSTATE" in res.text or \
                       "ORA-" in res.text: # Added Oracle error
                        print(f"[+] SQL Injection Detected on {action_url}")
                        print(f"Form details:")
                        print(details)
                        break # Stop after first detection for this form
                except requests.exceptions.RequestException as e:
                    print(f"[ ] Could not reach {action_url}: {e}")

def scan_broken_authentication(url, common_usernames=["admin", "user", "test"], common_passwords=["admin", "password", "123456"]):
    print(f"Scanning for Broken Authentication vulnerabilities on: {url}")
    forms = get_all_forms(url)
    
    for form in forms:
        details = form_details(form)
        action_url = urljoin(url, details["action"])
        method = details["method"]

        username_field = None
        password_field = None

        for input_tag in details["inputs"]:
            if "user" in input_tag["name"] or "email" in input_tag["name"]:
                username_field = input_tag["name"]
            if "pass" in input_tag["name"]:
                password_field = input_tag["name"]
        
        if username_field and password_field:
            print(f"Attempting to brute-force login on {action_url}")
            for user in common_usernames:
                for pwd in common_passwords:
                    data = {username_field: user, password_field: pwd}
                    try:
                        if method == "post":
                            res = requests.post(action_url, data=data, timeout=5)
                        elif method == "get":
                            res = requests.get(action_url, params=data, timeout=5)
                        
                        # Simple check for successful login (customize based on target application)
                        if "Welcome" in res.text or "Dashboard" in res.text or "Logout" in res.text:
                            print(f"[+] Broken Authentication Detected: {user}/{pwd} on {action_url}")
                            return # Stop after first successful login
                    except requests.exceptions.RequestException as e:
                        print(f"[ ] Could not reach {action_url}: {e}")
    print("[-] No obvious Broken Authentication vulnerabilities found.")

def scan_insecure_deserialization(url, payload_file=None):
    print(f"Scanning for Insecure Deserialization vulnerabilities on: {url}")
    print("This is a conceptual scan. Real-world insecure deserialization requires specific payload generation and server-side interaction.")
    print("Typically, this involves sending specially crafted serialized objects (e.g., Java, PHP, Python) and observing server behavior.")
    print("For a practical test, you would need to:\n1. Identify endpoints that deserialize user-supplied data.\n2. Craft a malicious serialized object (e.g., using Ysoserial for Java, PHPGGC for PHP).\n3. Send the payload and observe for RCE, privilege escalation, or DoS.")
    print("This simulator cannot execute real deserialization attacks.")

def scan_security_misconfiguration(url):
    print(f"Scanning for Security Misconfiguration vulnerabilities on: {url}")
    print("This is a conceptual scan. Real-world security misconfiguration checks involve:\n1. Checking for default credentials on common services (e.g., admin/admin, root/toor).\n2. Looking for exposed sensitive files (e.g., .git, .env, backup files, directory listings).\n3. Verifying proper error handling (e.g., verbose error messages revealing internal paths or database details).\n4. Checking for outdated software versions with known vulnerabilities.\n5. Ensuring proper HTTP headers are set (e.g., X-Frame-Options, Content-Security-Policy).")
    print("This simulator will perform a basic check for common exposed files and directory listing.")

    common_exposed_paths = [
        "/.git/config",
        "/.env",
        "/backup.zip",
        "/admin/",
        "/phpmyadmin/",
        "/test/",
        "/robots.txt",
        "/sitemap.xml",
        "/wp-admin/", # Common for WordPress
        "/config.php.bak" # Common backup file
    ]

    for path in common_exposed_paths:
        test_url = urljoin(url, path)
        try:
            res = requests.get(test_url, timeout=5)
            if res.status_code == 200 and "404 Not Found" not in res.text.lower() and "not found" not in res.text.lower():
                print(f"[+] Potentially exposed file/directory found: {test_url} (Status: {res.status_code})")
            elif res.status_code == 403:
                print(f"[ ] Access forbidden to {test_url} (Status: {res.status_code})")
        except requests.exceptions.RequestException as e:
            print(f"[ ] Could not reach {test_url}: {e}")

def scan_open_ports(target_ip, common_ports=[21, 22, 23, 25, 80, 110, 139, 443, 445, 3389, 8080]):
    print(f"Scanning for open ports on: {target_ip}")
    open_ports = []
    for port in common_ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((target_ip, port))
        if result == 0:
            print(f"[+] Port {port} is open")
            open_ports.append(port)
        sock.close()
    if not open_ports:
        print("[-] No common open ports found.")
    return open_ports

def scan_security_headers(url):
    print(f"Scanning for missing security headers on: {url}")
    try:
        res = requests.get(url, timeout=5)
        headers = res.headers
        missing_headers = []

        security_headers = {
            "Strict-Transport-Security": "HSTS header is missing, allowing downgrade attacks.",
            "Content-Security-Policy": "CSP header is missing, increasing XSS risk.",
            "X-Content-Type-Options": "X-Content-Type-Options header is missing, allowing MIME-sniffing attacks.",
            "X-Frame-Options": "X-Frame-Options header is missing, allowing clickjacking attacks.",
            "Referrer-Policy": "Referrer-Policy header is missing or insecure, potentially leaking referrer information."
        }

        for header, description in security_headers.items():
            if header not in headers:
                missing_headers.append(description)
        
        if missing_headers:
            print(f"[+] Missing Security Headers on {url}:")
            for missing in missing_headers:
                print(f"    - {missing}")
        else:
            print(f"[-] All common security headers are present on {url}.")

    except requests.exceptions.RequestException as e:
        print(f"[ ] Could not reach {url}: {e}")

def scan_vulnerability(target, vulnerability_type):
    if vulnerability_type == "xss":
        scan_xss(target)
    elif vulnerability_type == "sql_injection":
        scan_sql_injection(target)
    elif vulnerability_type == "broken_authentication":
        scan_broken_authentication(target)
    elif vulnerability_type == "insecure_deserialization":
        scan_insecure_deserialization(target)
    elif vulnerability_type == "security_misconfiguration":
        scan_security_misconfiguration(target)
    elif vulnerability_type == "open_ports":
        try:
            # Resolve URL to IP for port scanning
            ip_address = socket.gethostbyname(target.replace("http://", "").replace("https://", "").split("/")[0])
            scan_open_ports(ip_address)
        except socket.gaierror:
            print(f"[ ] Could not resolve IP address for {target}. Cannot perform port scan.")
    elif vulnerability_type == "security_headers":
        scan_security_headers(target)
    else:
        print("Unknown vulnerability type.")

if __name__ == "__main__":
    print("\n--- Advanced Vulnerability Scanner Simulator ---")
    target_input = input("Enter the target URL or IP address to scan: ")
    print("Select vulnerability type to simulate:")
    print("1. Cross-Site Scripting (XSS)")
    print("2. SQL Injection")
    print("3. Broken Authentication")
    print("4. Insecure Deserialization (Conceptual)")
    print("5. Security Misconfiguration (Conceptual)")
    print("6. Open Port Scan")
    print("7. Missing Security Headers")
    choice = input("Enter your choice (1-7): ")

    vulnerability_map = {
        "1": "xss",
        "2": "sql_injection",
        "3": "broken_authentication",
        "4": "insecure_deserialization",
        "5": "security_misconfiguration",
        "6": "open_ports",
        "7": "security_headers"
    }

    selected_vulnerability = vulnerability_map.get(choice)

    if selected_vulnerability:
        scan_vulnerability(target_input, selected_vulnerability)
    else:
        print("Invalid choice. Please run the script again and select a valid option.")



